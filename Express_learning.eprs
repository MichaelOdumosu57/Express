https://expressjs.com/en/starter/hello-world.html
https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods
https://www.w3schools.com/nodejs/met_path_join.asp

E-> are tips


E -> X -> P -> R -> E -> S -> S ->
                              E -> X -> P -> R -> E -> S -> S ->
														E -> X -> P -> R -> E -> S -> S ->
																					E -> X -> P -> R -> E -> S -> S ->														


E -> X -> P -> R -> E -> S -> S ->

to setup up a node environment with an express dependency
	install node
	npm init in a directory
	make the entry point app.js 
	npm install express --save
	node app.js




                              E -> X -> P -> R -> E -> S -> S ->

hello world
		const express = require('express')
		const app = express()
		const port = 3000

		app.get('/', (req, res) => res.send('Hello World!'))

		app.listen(port, () => console.log(`Example app listening on port ${port}!`))	
				file:basic_app/hello_world.js

														E -> X -> P -> R -> E -> S -> S ->


app.METHOD(PATH, HANDLER)
Where:

app is an instance of express.
METHOD is an HTTP request method, in lowercase.
PATH is a path on the server.
HANDLER is the function executed when the route is matched.


																					E -> X -> P -> R -> E -> S -> S ->

METHOD 
		GET
		The GET method requests a representation of the specified resource. Requests using GET should only retrieve data and should have no other effect.
		HEAD
		The HEAD method retrieves meta-information written in response headers without the response body., without having to transport the entire content.
		POST
		its giving an object data tot the server
		PUT
		modifes existing resources if target resources is there for the changes client side or makes a new one if target reosurce is not present in server side  
		DELETE
		The DELETE method deletes the specified resource.
		TRACE
		The TRACE method echoes the received request so that a client can see what (if any) changes or additions have been made by intermediate servers.
		OPTIONS
		The OPTIONS method returns the HTTP methods that the server supports for the specified URL. This can be used to check the functionality of a web server by requesting '*' instead of a specific resource.
		CONNECT
		[25] The CONNECT method converts the request connection to a transparent TCP/IP tunnel, usually to facilitate SSL-encrypted communication (HTTPS) through an unencrypted HTTP proxy.[26][27] See HTTP CONNECT method.
		PATCH
		The PATCH method applies partial modifications to a resource.[28]

				All general-purpose HTTP servers are required to implement at least the GET and HEAD methods, and all other methods are considered optional by the specification.[29]

						Safe methods
						Some of the methods (for example, HEAD, GET, OPTIONS and TRACE) are, by convention, defined as safe, which means they are intended only for information retrieval and should not change the state of the server.

						By contrast, methods such as POST, PUT, DELETE and PATCH are intended for actions that may cause side effects either on the server, or external side effects such as financial transactions or transmission of email. Such methods are therefore not usually used by conforming web robots or web crawlers; some that do not conform tend to make requests without regard to context or consequences.


E -> X -> P -> R -> E -> S -> S ->

Serving static files in Express

to access a sub_directory where the express app is running 
		app.use(express.static('[directory_name]'))
				to access several directories you must call this several times
file:static_serving/serve_static.js 


to access a dir not on the filesystem
		app.use('/static', express.static('public'))



to access a subdir
		app.use('[path location of subdir]', express.static(path.join(__dirname,'[parent_dir....]', '[subdir]')))
				to use path you must requrie it 
				var path = require('path');
file:static_serving/serve_diff_dir.js

to serve a html file from the GET request itself
		app.get('/', (req, res) => res.sendFile(__dirname + '/template.html'))
file:/static_serving/serve_html.js

E-> If you are serving many assets from a directory, use the express.static() middleware function.


                              E -> X -> P -> R -> E -> S -> S ->

Route paths

If using a $ in a path escapt it with [] like this 
		 “/data/$book”, would be “/data/([\$])book”.                              


to match for the root diretory 
		app.get('/', function (req, res) {
		  res.send('root')
		})
file: /routing_basic/root_dir.js


to match for the sub_directory
		app.get('/sub_directory', function (req, res) {
		  res.send('sub_directory')
		})		
file: /routing_basic/root_dir.js	


to match for  acd and abcd.
		app.get('/ab?cd', function (req, res) {
		  res.send('ab?cd')
		})	
file: /routing_basic/root_dir.js			


to match for as many b's in a row ' for abcd 
		app.get('/ab+cd', function (req, res) {
		  res.send('ab+cd')
		})
file: /routing_basic/root_dir.js	


to match for   abcd, abxcd, abRANDOMcd, ab123cd
		app.get('/ab*cd', function (req, res) {
		  res.send('ab*cd')
		})
file: /routing_basic/root_dir.js	

to regex for "a"
		app.get(/a/, function (req, res) {
		  res.send('/a/')
		})
file: /routing_basic/root_dir.js		


to match for butterfly and dragonfly, but not butterflyman, dragonflyman
		app.get(/.*fly$/, function (req, res) {
		  res.send('/.*fly$/')
		})	 
file: /routing_basic/root_dir.js				
														E -> X -> P -> R -> E -> S -> S ->

Route parameters														
varables in paths 


any dir in a path that starts wit a ':' is a variable filled when the user or script makes a GET request to the express app
		app.get('/users/:userId/books/:bookId', function (req, res) {  
		  res.send(req.params)
		})		
				Route path: /users/:userId/books/:bookId
				Request URL: http://localhost:3000/users/34/books/8989
				would return req.params: { "userId": "34", "bookId": "8989" }
file: /routing_basic/routing_params/params.js


using  hyphen (-) 
		app.get('/flights/:from-:to', function (req, res) {  
		  res.send(req.params)
		})	
				Route path: /flights/:from-:to
				Request URL: http://localhost:3000/flights/LAX-SFO
				req.params: { "from": "LAX", "to": "SFO" }
file: /routing_basic/routing_params/params.js						


dot (.)
		app.get('/plantae/:genus.:species', function (req, res) {  
		  res.send(req.params)
		})	
				Route path: /plantae/:genus.:species
				Request URL: http://localhost:3000/plantae/Prunus.persica
				req.params: { "genus": "Prunus", "species": "persica" }
file: /routing_basic/routing_params/params.js						

E-> so we see a dir does not to need to literally exist in order for certain actions to be done


use a parentheses for regex 
		app.get('/user/:userId(\\d+)', function (req, res) {  
		  res.send(req.params)
		})	
				Route path: /user/:userId(\\d+)
				Request URL: http://localhost:3000/user/42
				req.params: {"userId": "42"}
file: /routing_basic/routing_params/params.js	

E-> in order to make a regex match you must escape any regex literals such as \w \d withe the '\' ' symbol
E->In Express 4.x, the * character in regular expressions is not interpreted in the usual way. As a workaround, use {0,} instead of *. 
This will likely be fixed in Express 5.




																					E -> X -> P -> R -> E -> S -> S ->
Route handlers				

there are multi request handling callbacks when give a wider functionality
		app.get('/example/b', function (req, res, next) {
		  console.log('the response will be sent by the next function ...')
		  next()
		}, function (req, res) {
		  res.send('Hello from B!')
		})
file: routing_basic/multi_routing/multi_routing.js		

E-> to include a var in a tilde string (especially on servers) use ${}


An array of callback functions can handle a route.
		var cb0 = function (req, res, next) {
		  console.log('CB0')
		  next()
		}

		var cb1 = function (req, res, next) {
		  console.log('CB1')
		  next()
		}

		var cb2 = function (req, res) {
		  res.send('Hello from C!')
		}

		app.get('/example/c', [cb0, cb1, cb2])
file: routing_basic/multi_routing/multi_routing.js		


A combination of independent functions and arrays of functions can handle a route. For example:

		var cb0 = function (req, res, next) {
		  console.log('CB0')
		  next()
		}

		var cb1 = function (req, res, next) {
		  console.log('CB1')
		  next()
		}

		app.get('/example/d', [cb0, cb1], function (req, res, next) {
		  console.log('the response will be sent by the next function ...')
		  next()
		}, function (req, res) {
		  res.send('Hello from D!')
		})


file: routing_basic/multi_routing/multi_routing.js		

E-> can only use res.send once in these multi routing function calls 	


E -> X -> P -> R -> E -> S -> S ->

Response methods
how the express app responds when it gets a client request

if a Response method is not called from a route handler, the client request will be left hanging.
		app.get('/hang_request', function (req, res, next) {
		  //no response method  
		})
				so it will be constantly loading or a timer will be availble in the client to let the user know a resource is not available
				if the daemon quits then the client responds with a message to the user 
file:/response_methods/response_methods.js

res.download()
		to download a file 
				res.download('/report-12345.pdf');

		if the first is missing it throws an error however if the first is present it downloads the second only
				res.download('/report-12345.pdf', '/report.pdf');

		download error handler 
				res.download('/report-12345.pdf', 'report.pdf', function(err){
					  if (err) {
					    // Handle error, but keep in mind the response may be partially-sent
					    // so check res.headersSent
					  } 
					  else {
					    // decrement a download credit, etc.
					  }
				});

		app.get('/download', function (req, res) {
				res.download("[file]")
		})
file:/response_methods/response_methods.js



res.end([data] [, encoding])
Use to quickly end the response without any data. I
	res.end();
	this leaves the user with a blank page
	res.status(404).end();
file:/response_methods/response_methods.js


E-> use res.status to learn about many HTTP  response protocol 403  is authorization protocol


res.json()
Sends a JSON response. This method sends a response (with the correct content-type) 
that is the parameter converted to a JSON string using JSON.stringify().
The parameter can be any JSON type, including object, array, string, Boolean, number, or null, 
jsonp has callback support 
and you can also use it to convert other values to JSON.
		res.json(null);
		res.json({ user: 'tobi' });
		res.status(500).json({ error: 'message' });

		res.jsonp(null);
		// => callback(null)

		res.jsonp({ user: 'tobi' });
		// => callback({ "user": "tobi" })

		res.status(500).jsonp({ error: 'message' });
		// => callback({ "error": "message" })		
file:/response_methods/response_methods.js

E-> res.json really returns the data it gets, it doesnt try to modify it


res.redirect([status,] path)
redirect a request
		res.redirect('/foo/bar');
		res.redirect('http://example.com');
		res.redirect(301, 'http://example.com');
		res.redirect('../login');
file:/response_methods/response_methods.js		

E-> do  not connect your routes to example.com the system deep links it and can ruin future plans with  your app 



                              E -> X -> P -> R -> E -> S -> S ->
														E -> X -> P -> R -> E -> S -> S ->
																					E -> X -> P -> R -> E -> S -> S ->														
