https://expressjs.com/en/starter/hello-world.html
https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods
https://www.w3schools.com/nodejs/met_path_join.asp
https://expressjs.com/en/api.html#req
https://github.com/senchalabs/connect#middleware

E-> are tips


E -> X -> P -> R -> E -> S -> S ->
                              E -> X -> P -> R -> E -> S -> S ->
														E -> X -> P -> R -> E -> S -> S ->
																					E -> X -> P -> R -> E -> S -> S ->														


E -> X -> P -> R -> E -> S -> S ->

to setup up a node environment with an express dependency
	install node
	npm init in a directory
	make the entry point app.js 
	npm install express --save
	node app.js




                              E -> X -> P -> R -> E -> S -> S ->

hello world
		const express = require('express')
		const app = express()
		const port = 3000

		app.get('/', (req, res) => res.send('Hello World!'))

		app.listen(port, () => console.log(`Example app listening on port ${port}!`))	
				file:basic_app/hello_world.js

														E -> X -> P -> R -> E -> S -> S ->


app.METHOD(PATH, HANDLER)
Where:

app is an instance of express.
METHOD is an HTTP request method, in lowercase.
PATH is a path on the server.
HANDLER is the function executed when the route is matched.


																					E -> X -> P -> R -> E -> S -> S ->

METHOD 
		GET
		The GET method requests a representation of the specified resource. 
		Requests using GET should only retrieve data and should have no other effect.
		HEAD
		The HEAD method retrieves meta-information written in response headers without the response body.,
		 without having to transport the entire content.
		POST
		its giving an object data to the server
		PUT
		modifes existing resources if target resources is there for the changes 
		client side or makes a new one if target reosurce is not present in server side  
		DELETE
		The DELETE method deletes the specified resource.
		TRACE
		The TRACE method echoes the received request so that a client can see 
		what (if any) changes or additions have been made by intermediate servers.
		OPTIONS
		The OPTIONS method returns the HTTP methods that the server supports for the specified URL.
		 This can be used to check the functionality of a web server by requesting '*' instead of a specific resource.
		CONNECT
		[25] The CONNECT method converts the request connection to a transparent TCP/IP tunnel, 
		usually to facilitate SSL-encrypted communication (HTTPS) through an unencrypted HTTP proxy.
		[26][27] See HTTP CONNECT method.
		PATCH
		The PATCH method applies partial modifications to a resource.[28]

				All general-purpose HTTP servers are required to implement at least the GET and HEAD methods, 
				and all other methods are considered optional by the specification.[29]

						Safe methods
						Some of the methods (for example, HEAD, GET, OPTIONS and TRACE) are, 
						by convention, defined as safe, which means they are intended only for
						 information retrieval and should not change the state of the server.

						By contrast, methods such as POST, PUT, DELETE and PATCH are intended for
						 actions that may cause side effects either on the server, or external 
						 side effects such as financial transactions or transmission of email. 
						 Such methods are therefore not usually used by conforming web robots or web crawlers;
						  some that do not conform tend to make requests without regard to context or consequences.



E -> X -> P -> R -> E -> S -> S ->

Serving static files in Express

to access a sub_directory where the express app is running 
		app.use(express.static('[directory_name]'))
				to access several directories you must call this several times
file:static_serving/serve_static.js 


to access a dir not on the filesystem
		app.use('/static', express.static('public'))



to access a subdir
		app.use('[path location of subdir]', express.static(path.join(__dirname,'[parent_dir....]', '[subdir]')))
				to use path you must requrie it 
				var path = require('path');
		to accces
			/[path location of subdir]/[file in subdir]
file:static_serving/serve_diff_dir.js

to serve a html file from the GET request itself
		app.get('/', (req, res) => res.sendFile(__dirname + '/template.html'))
file:/static_serving/serve_html.js

E-> If you are serving many assets from a directory, use the express.static() middleware function.
E-> refer to the file  below it helps plenty 
express.static(root, [options])

+--------------+--------------------------------------------------------------------------+----------+--------------+--------------+
| Property     | Description                                                              | Type     | Default      |Values        |
+--------------+--------------------------------------------------------------------------+----------+--------------+--------------+
| dotfiles     | Determines how dotfiles (files or directories that begin with a dot “.”) 							 "allow","deny"
				  are treated. See dotfiles below.(it will not ignore .[directory])       | String   | “ignore”     |"ignore"      |
+--------------+--------------------------------------------------------------------------+----------+--------------+--------------+
| etag         | Enable or disable etag generation NOTE:
				 express.static always sends weak ETags.                                  | Boolean  | true         |              | 
+--------------+--------------------------------------------------------------------------+----------+--------------+--------------+
| extensions   | Sets file extension fallbacks: If a file is not found search for
				 files with the specified extensions and serve the 1st
				 . Example: ['html' 'htm'] (if an extension is given it doesnt work )     | Mixed    | false        |              |
+--------------+--------------------------------------------------------------------------+----------+--------------+--------------+
| fallthrough  | Let client errors fall-through as
				 unhandled requests otherwise forward a client error. 
				 this means if a url path is not on the server its handled in express     | Boolean  | true         |              |
+--------------+--------------------------------------------------------------------------+----------+--------------+--------------+
| immutable    | Enable or disable the immutable directive in the 
				Cache-Control response header. If enabled the maxAge option 
				should also be specified to enable caching. 
				The immutable directive will prevent
				 supported clients from making conditional 
				requests during the life of the maxAge option to
				 check if the file has changed.                                            | Boolean  | false        |              |
+--------------+---------------------------------------------------------------------------+----------+--------------+--------------+
| index        | Sends the specified directory index file. 
				 Set to false to disable directory indexing. cannot be true                | Mixed    | “index.html” |              | 
+--------------+---------------------------------------------------------------------------+----------+--------------+--------------+
| lastModified | Set the Last-Modified header to the last
				 modified date of the file on the OS.                                      | Boolean  | true         |              |
+--------------+---------------------------------------------------------------------------+----------+--------------+--------------+
| maxAge       | Set the max-age property of the 
				 Cache-Control header in milliseconds or a string in ms format.            | Number   | 0            |              |
+--------------+---------------------------------------------------------------------------+----------+--------------+--------------+
| redirect     | Redirect to trailing “/” when the pathname is a directory.                | Boolean  | true         |              |
+--------------+---------------------------------------------------------------------------+----------+--------------+--------------+
| setHeaders   | Function for setting HTTP headers to serve with the file.
				 fn(res -- res obj, path --path to file, stat --fs.stats obj)              | Function |              |              |
+--------------+---------------------------------------------------------------------------+----------+--------------+--------------+

file : EXPRESS/static_serving/express_static.js
                              E -> X -> P -> R -> E -> S -> S ->

Route paths

If using a $ in a path escapt it with [] like this 
		 “/data/$book”, would be “/data/([\$])book”.                              


to match for the root diretory 
		app.get('/', function (req, res) {
		  res.send('root')
		})
file: /routing_basic/root_dir.js


to match for the sub_directory
		app.get('/sub_directory', function (req, res) {
		  res.send('sub_directory')
		})		
file: /routing_basic/root_dir.js	


to match for  acd and abcd.
		app.get('/ab?cd', function (req, res) {
		  res.send('ab?cd')
		})	
file: /routing_basic/root_dir.js			


to match for as many b's in a row ' for abcd 
		app.get('/ab+cd', function (req, res) {
		  res.send('ab+cd')
		})
file: /routing_basic/root_dir.js	


to match for   abcd, abxcd, abRANDOMcd, ab123cd
		app.get('/ab*cd', function (req, res) {
		  res.send('ab*cd')
		})
file: /routing_basic/root_dir.js	

to regex for "a"
		app.get(/a/, function (req, res) {
		  res.send('/a/')
		})
file: /routing_basic/root_dir.js		


to match for butterfly and dragonfly, but not butterflyman, dragonflyman
		app.get(/.*fly$/, function (req, res) {
		  res.send('/.*fly$/')
		})	 

		
	
file: /routing_basic/root_dir.js				
														E -> X -> P -> R -> E -> S -> S ->

Route parameters														
varables in paths 


any dir in a path that starts wit a ':' is a variable filled when the user or script makes a GET request to the express app
		app.get('/users/:userId/books/:bookId', function (req, res) {  
		  res.send(req.params)
		})		
				Route path: /users/:userId/books/:bookId
				Request URL: http://localhost:3000/users/34/books/8989
				would return req.params: { "userId": "34", "bookId": "8989" }
file: /routing_basic/routing_params/params.js


using  hyphen (-) 
		app.get('/flights/:from-:to', function (req, res) {  
		  res.send(req.params)
		})	
				Route path: /flights/:from-:to
				Request URL: http://localhost:3000/flights/LAX-SFO
				req.params: { "from": "LAX", "to": "SFO" }
file: /routing_basic/routing_params/params.js						


dot (.)
		app.get('/plantae/:genus.:species', function (req, res) {  
		  res.send(req.params)
		})	
				Route path: /plantae/:genus.:species
				Request URL: http://localhost:3000/plantae/Prunus.persica
				req.params: { "genus": "Prunus", "species": "persica" }

					
file: /routing_basic/routing_params/params.js						

E-> so we see a dir does not to need to literally exist in order for certain actions to be done


use a parentheses for regex 
		app.get('/user/:userId(\\d+)', function (req, res) {  
		  res.send(req.params)
		})	
				Route path: /user/:userId(\\d+)
				Request URL: http://localhost:3000/user/42
				req.params: {"userId": "42"}
file: /routing_basic/routing_params/params.js	

E-> in order to make a regex match you must escape any regex literals such as \w \d withe the '\' ' symbol
E->In Express 4.x, the * character in regular expressions is not interpreted in the usual way. As a workaround, use {0,} instead of *. 
This will likely be fixed in Express 5.




																					E -> X -> P -> R -> E -> S -> S ->
Route handlers				

there are multi request handling callbacks when give a wider functionality
		app.get('/example/b', function (req, res, next) {
		  console.log('the response will be sent by the next function ...')
		  next()
		}, function (req, res) {
		  res.send('Hello from B!')
		})
file: routing_basic/multi_routing/multi_routing.js		

E-> to include a var in a tilde string (especially on servers) use ${}


An array of callback functions can handle a route.
		var cb0 = function (req, res, next) {
		  console.log('CB0')
		  next()
		}

		var cb1 = function (req, res, next) {
		  console.log('CB1')
		  next()
		}

		var cb2 = function (req, res, next) {
		  res.send('Hello from C!')
		}

		app.get('/example/c', [cb0, cb1, cb2])
file: routing_basic/multi_routing/multi_routing.js		


A combination of independent functions and arrays of functions can handle a route. For example:

		var cb0 = function (req, res, next) {
		  console.log('CB0')
		  next()
		}

		var cb1 = function (req, res, next) {
		  console.log('CB1')
		  next()
		}

		app.get('/example/d', [cb0, cb1], function (req, res, next) {
		  console.log('the response will be sent by the next function ...')
		  next()
		}, function (req, res, next) {
		  res.send('Hello from D!')
		})


file: routing_basic/multi_routing/multi_routing.js		

E-> can only use res.send once in these multi routing function calls 	


E -> X -> P -> R -> E -> S -> S ->

Response methods
how the express app responds when it gets a client request

if a Response method is not called from a route handler, the client request will be left hanging.
		app.get('/hang_request', function (req, res, next) {
		  //no response method  
		})
				so it will be constantly loading or a timer will be availble in the client to
				 let the user know a resource is not available
				if the daemon quits then the client responds with a message to the user 
file:/response_methods/response_methods.js

res.download()
		to download a file 
				res.download('/report-12345.pdf');

		the second argument renames the files on download
				res.download('/report-12345.pdf', '/report.pdf');

		download error handler 
				res.download('/report-12345.pdf', 'report.pdf', function(err){
					  if (err) {
					    // Handle error, but keep in mind the response may be partially-sent
					    // so check res.headersSent
					  } 
					  else {
					    // decrement a download credit, etc.
					  }
				});

		app.get('/download', function (req, res) {
				res.download("[file]")
		})
file:/response_methods/response_methods.js



res.end([data] [, encoding])
Use to quickly end the response without any data. 
	res.end();
	this leaves the user with a blank page
	res.status(404).end();
file:/response_methods/response_methods.js


E-> use res.status to learn about many HTTP  response protocol 403  is authorization protocol


res.json()
Sends a JSON response. This method sends a response (with the correct content-type) 
that is the parameter converted to a JSON string using JSON.stringify().
The parameter can be any JSON type, including object, array, string, Boolean, number, or null, 
jsonp has callback support 
and you can also use it to convert other values to JSON.
		res.json(null);
		res.json({ user: 'tobi' });
		res.status(500).json({ error: 'message' });

		res.jsonp(null);
		// => callback(null)

		res.jsonp({ user: 'tobi' });
		// => callback({ "user": "tobi" })

		res.status(500).jsonp({ error: 'message' });
		// => callback({ "error": "message" })		
file:/response_methods/response_methods.js

E-> res.json really returns the data it gets, it doesnt try to modify it


res.redirect([status,] path)
redirect a request
		res.redirect('/foo/bar');
		res.redirect('http://example.com');
		res.redirect(301, 'http://example.com');
		res.redirect('../login');
file:/response_methods/response_methods.js		

E-> do  not connect your routes to example.com the system deep links it and can ruin future plans with  your app 

res.render(view [, locals] [, callback])
Render a view template.
we wont be using this, 

E-> refer to res.render for REact and Redux


res.set(field [, value])
sets the content type before sending data
		res.set('Content-Type', 'text/html');
		res.send(new Buffer('<p>some html</p>'));

		res.set({
		  'Content-Type': 'text/plain',
		  'Content-Length': '1',
		  
		});		
E-> it seems at a basic level content-length does not affect anything but please try not to include this parameter if working with 
dynamics in size		
file:/response_methods/response_methods.js		

E-> depending on the content type the browser modifies how you see the data


res.sendFile
the options parameter
		+--------------+------------------------------------------------------------------------------ +----------+--------------+
		| ﻿"Property"   | Description                                                                   | Default  | Availability |
		+--------------+------------------------------------------------------------------------------ +----------+--------------+
		| maxAge       | Sets the max-age property of the Cache-Control 
		|              | header in milliseconds or a string in ms format                               | 0        |              |
		+--------------+-------------------------------------------------------------------------------+----------+--------------+
		| root         | Root directory for relative filenames.                                        |          |              |
		+--------------+-------------------------------------------------------------------------------+----------+--------------+
		| lastModified | Sets the Last-Modified header to the last modified date 
		|              |of the file on the OS. Set false to disable it.                                | Enabled  | 4.9.0+       |
		+--------------+-------------------------------------------------------------------------------+----------+--------------+
		| headers      | Object containing HTTP headers to serve with the file.                        |          |              |
		+--------------+-------------------------------------------------------------------------------+----------+--------------+
		| dotfiles     | Option for serving dotfiles. Possible values are “allow”, “deny”, “ignore”.   | “ignore” |              |
		+--------------+-------------------------------------------------------------------------------+----------+--------------+
		| acceptRanges | Enable or disable accepting ranged requests.                                  | true     | 4.14+        |
		+--------------+-------------------------------------------------------------------------------+----------+--------------+
		| cacheControl | Enable or disable setting Cache-Control response header.                      | true     | 4.14+        |
		+--------------+-------------------------------------------------------------------------------+----------+--------------+
		| immutable    | Enable or disable the immutable directive in the Cache-Control
		|              |response header. If enabled, the maxAge option 
		|              | should also be specified to
		|              | enable caching. The immutable directive will prevent supported clients 
		|              | from making conditional requests during the life of the maxAge 
		|              | option to check if the file has changed.                                      | false    | 4.16+        |
		+--------------+-------------------------------------------------------------------------------+----------+--------------+


all arguments 
		app.get('/file/:name', function (req, res, next) {

		  var options = {
		    root: __dirname + '/public/',
		    dotfiles: 'deny',
		    headers: {
		        'x-timestamp': Date.now(),
		        'x-sent': true
		    }
		  };

		  var fileName = req.params.name;
		  res.sendFile(fileName, options, function (err) {
		    if (err) {
		      next(err);
		    } else {
		      console.log('Sent:', fileName);
		    }
		  });

		});

E -> use this to get around express.static bugs 
E-> although express is serving static files here if you have a server side code moving things around, 
	there can be a dynamaic concept applied 		
file:/response_methods/response_methods.js	

preventing use of some files

app.get('/sendFile/:name', function (req, res, next) {

    var name = req.params.name
    mayViewFilesFrom(   name,res   )
    
});

    function  mayViewFilesFrom (yes, response){
      if (yes == "a.txt") {
        response.sendFile(__dirname + "/" + yes);
      } 

      else {
        response.status(403).send("Sorry! You can't see that.");
      }
    }

file:/response_methods/response_methods.js	


res.sendStatus
some status codes 
		res.sendStatus(200); // equivalent to res.status(200).send('OK')
		res.sendStatus(403); // equivalent to res.status(403).send('Forbidden')
		res.sendStatus(404); // equivalent to res.status(404).send('Not Found')
		res.sendStatus(500); // equivalent to res.status(500).send('Internal Server Error')





                              E -> X -> P -> R -> E -> S -> S ->

app.route ()
helps when writing too many route handlers 
		app.route('/book')
		  .get(function (req, res) {
		    res.send('Get a random book')
		  })
		  .post(function (req, res) {
		    res.send('Add a book')
		  })
		  .put(function (req, res) {
		    res.send('Update the book')
		  })
file: /route_handler_handler/route_handler_handler.js	


E-> use this function when dealing with a Converting circular structure to JSON error
		const getCircularReplacer = () => {
		  const seen = new WeakSet();
		  return (key, value) => {
		    if (typeof value === "object" && value !== null) {
		      if (seen.has(value)) {
		        return;
		      }
		      seen.add(value);
		    }
		    return value;
		  };
		};	          
		JSON.stringify([circular object], getCircularReplacer());   
file: /route_handler_handler/get_req_message.js			 

														E -> X -> P -> R -> E -> S -> S ->
express.Router
might have to use this to communicate with databases		
when you have project purposes for express  and you have a mega project instead of making a mega app 
you can make you own modular apps with the express.Router function, which allows you to pick and choose your "sub"-Router
and save time rewriting huge picecs of code, make sure they are intrgratedabebly sound!!


for the routing module
var express = require('express')
var router = express.Router()	
		replace app with router it works just the same with all methods but investigate to make sure 
				at the end of your express Router
				module.exports = router	
						then load the router in the express app 
								var custom_router = require('./custom_router')
								...
								app.use('/custom_router', custom_router)	
										this will handle anythings related to the "/custom_router" path entered by the user 
										you need to use "/custom_router" with your requests to acccess and activate the router
E-> think of the router as the hand but the app as the brains that what it really is
E-> when you use app.use on a router the path you give as the first parameter must be included before using the Router's own paths'

+---------------+-------------------------------------+-------------------------------+--------------+
| Property      | Description                         | Default                       | Availability |
+---------------+-------------------------------------+-------------------------------+--------------+
| caseSensitive | Enable case sensitivity.            | Disabled by default treating 
                  doesnt work                          “/Foo” and “/foo” as the same. |              |
+---------------+-------------------------------------+-------------------------------+--------------+
| mergeParams   | Preserve the req.params values 
|				|  from the parent router.
|				| If the parent and the child have 
|				| conflicting param names the child’s 
|				| value take precedence.   
                  always uses the children param      | false                         | 4.5.0+       |
+---------------+-------------------------------------+-------------------------------+--------------+
| strict        | Enable strict routing.  doenst work | Disabled by default 
														“/foo” and “/foo/”            |              |
														are treated the
														same by the router.
+---------------+-----------------------------------------+---------------------------+--------------+
directory:/the_express_router run :use_express_router.js										



																					E -> X -> P -> R -> E -> S -> S ->														

Writing middleware for use in Express apps
Middleware functions are functions that have access to the request object (req),
 the response object (res), and the next function in the application’s request-response cycle
		If the current middleware function does not end the request-response cycle, 
		it must call next() to
		pass control to the next middleware function. 
		Otherwise, the request will be left hanging. 

what middleware looks like
		var myMiddleware = function (req, res, next) {
		  console.log('Middleware')
		  next()
		}
			to load it
				app.use(myMiddleware)
						to run it it needs to be loaded before a http method of an express app triggered by request

using middleware
		var express = require('express')
		var app = express()

		var myLogger = function (req, res, next) {
		  console.log('LOGGED')
		  next()
		}

		app.use(myLogger)

		app.get('/', function (req, res) {
		  res.send('Hello World!')
		})

		app.listen(3000)		
file: /middleware/basic_middleware.js
E-> the middleware must be loaded before the apps http method call 

E -> X -> P -> R -> E -> S -> S ->
Configurable middleware
some times you dont want your app to be static loading everything it needs when production needs one router or middleware
to solve that use this middleware config purpose 
		
		
		module.exports = function(options) {
		  return function(req, res, next) {
		    if(options.option1 == "1"){
		    	console.log(" reacting")
		    }
		    if(options.option2 == "2"){
		    	console.log(" reacting some more")
		    }	
		    next()
		  }
		}
		file:/middleware/my-middleware.js


				in the app
				var mw = require('./my-middleware.js')
				app.use(mw({ option1: '1', option2: '2' }))
file: /middleware/config_middleware.js


                              E -> X -> P -> R -> E -> S -> S ->
Using middleware
	Application middleware 
to send a req to the next route
		app.get('/:id', function (req, res, next) {
		  // if the user ID is 0, skip to the next route
		  if (req.params.id === '0') next('route')
		  // otherwise pass the control to the next middleware function in this stack
		  else next()
		}, function (req, res, next) {
		  // send a regular response
		  res.send('regular')
		})

		// handler for the /user/:id path, which sends a special response
		app.get('/:id', function (req, res, next) {
		  res.send('special')
		})	
file:/middleware/application/application.js
E-> if express complains about several res.send calls, use a route to fix things

	Router middleware
to apply a route to all HTTP methods on an express router use its 'use' method
		router.use('/user/:id', function (req, res, next) {
		  console.log('Request URL:', req.originalUrl)
		  next()
		}, function (req, res, next) {
		  console.log('Request Type:', req.method)
		  next()
		})
file:/the_express_router/birds.js


to skip a router after a condition use  next('router')
		router.use(function (req, res, next) {
		  if (!req.headers['x-auth']) return next('router')
		  next()
		})

		router.get('/', function (req, res) {
		  res.send('hello, user!')
		})

		// use the router and 401 anything falling through
		app.use('/admin', router, function (req, res) {
		  res.sendStatus(401)
		})
E -> very very useful for securing access to your work if someone gets their hands on your computer		
file:/the_express_router/router_skip.js


		Error-handling middleware
				Must use four parameters
						determine if your method is sync  (use try catch throw) 
						or async go to async_error_handle.js it works
						file:async_error_handle.js


		Built-in middleware	
				Starting with version 4.x, Express no longer depends on Connect. The middleware functions 
				that were previously included with Express are now in separate modules; see the list of middleware functions.

		Third-party middleware
				npm? you know how to do that a list 
				https://github.com/senchalabs/connect#middleware


														E -> X -> P -> R -> E -> S -> S ->
Error handling 
	Error Handling refers to how Express catches and
	processes errors that occur both synchronously and asynchronously.
		express can catch synchronous code errors by itself but needs and error handler to deal with
		asynchronous code 
		E-> write all your code with error handlers since express wont tell you the difference 
				If you pass anything to the next() function (except the string 'route'), 
				Express regards the current request as being an error and will skip 
				any remaining non-error handling routing and middleware functions.
				it will print whatever is in the next arg to the client and to stdout, 
				E-> if this is javascript it sends it perfectly, so you can use this as a bypass if the receving end can
				 take it and run it   
				file: the_express_router/router_skip.js

Use promises to avoid the overhead of the try..
catch block or when using functions that return promises. For example:	
this gets the job done 	

app.get("/", function (req, res, next) {
  Promise.resolve()
  .then(function(rel){
      // afaga
      console.log("some code")
      res.send("ok")
  }).catch(next)
},function (  err, req, res, next) {  
  res.send("the promise caught the error")
}); 

E-> on this system dont use promises to handle errors, dont use promises for express, dont code with sync code 				

The default error handler 
	If you pass an error to next() and you do not handle it in a custom error handler, 
	it will be handled by the built-in error handler; the error will be written to the client with the stack trace.
	The stack trace is not included in the production environment.

E-> Set the environment variable NODE_ENV to production, to run the app in production mode.

if you call the next() while express writes a response to a client and an error occurs  it will close the connection and 
fail the request 

do this instead as a callback 
		function  (err, req, res, next) {
		  if (res.headersSent) {
		    return next(err) //fix what needs to be fixed use the 'error' event to further fix things
		    // hopefully have enough information from the req to make another req and send a fixed res
		    // or let the client know if something went wrong, refresh the button 
		  }
		  else{
		  		res.redirect([path]) and further redirects till you can use 'error' evebnt tofix the problem
		  }
		  res.status(500)
		  res.render('just reload me', { error: err })
		} 

 	add this if its not helping

		res.on('error',function(err){
			console.log(err)
		})



Writing error handlers
	they have four arguments
		app.use(function (err, req, res, next) {
		  console.error(err.stack)
		  res.status(500).send('Something broke!')
		})			

E-> error handlers are for async functions that throw errors, if it does not throw an error the error handler callback
	will be skipped, and your inteneded code for dynamaics will be skipped also. Use a regular function and put them together

file: async_error_handle.js


																					E -> X -> P -> R -> E -> S -> S ->	

Debugging Express

Logging is turned off by default and can be conditionally turned on by using the DEBUG environment variable.
you dont have to comment it out during production

To see all the internal logs used in Express, set the DEBUG environment variable to express:* when launching your app.
		$ DEBUG=express:* node index.js

To see the logs only from the router implementation set the value of DEBUG to express:router. Likewise, to see logs only 
from the application implementation set the value of DEBUG to express:application, and so on.																							

Applications generated by express
		express sample-app
			to Debugging	
				$ DEBUG=sample-app:* node ./bin/www
		Routers		
		express http
		express mail 
		express express	  	
			to debug
				$ DEBUG=http,mail,express:* node index.js		

Express behind proxies
	refer for help

E -> X -> P -> R -> E -> S -> S ->
Database integration
https://expressjs.com/en/guide/database-integration.html
you need the database there in order for things to work 



                              E -> X -> P -> R -> E -> S -> S ->
Best performance practices 

Use gzip compression
	var compression = require('compression')
	var express = require('express')
	var app = express()
	app.use(compression())	
		file:template_app.js

				for high traffic websites its best to do gzip in a reverse proxy --> NGINX :))

Don’t use synchronous functions
	If you are using Node.js 4.0+ or io.js 2.1.0+, you can use the 	--trace-sync-io command-line flag 
	to print a warning and a stack trace whenever your application uses a synchronous API.
		dont use the flag in production

Do logging correctly
	if you use console.log or console.error pipe the output to another program to avoid synchronous activity 
	also use the special debug module to control which messages are sent to console.err (what part of the program you want
		to debug )

For app activity

	If you’re logging app activity (for example, tracking traffic or API calls),
	 instead of using console.log(), use a logging library like Winston or Bunyan. 
	 For a detailed comparison of these two libraries, see the StrongLoop blog post 
	 Comparing Winston and Bunyan Node.js Logging.

Handle exceptions properly
	
	node apps crash when the run into an uncaught exception


		What not to do
			dont listen for the uncaughtException event, this will modify the node proccess so that it will continue
			 to run and become unpreditcable to your system resources and probably unresponisve to your system manager
			 you dont want the second one in production
			 		crashing and restarting is sometimes the most reliable way to recover from an error
			 		don't use domains ' it generally does not solve the problem 

			 				dont use try throw catch with asynchronous code use only for synchronous code, if you need to
			 				throw an error use console.error, it will handle properly  


		 Use promises	
		 		Promises will handle any exceptions (both explicit and implicit) in asynchronous 
		 		code blocks that use then(). 
		 		Just add .catch(next) to the end of promise chains.		
				app.get("/", function (req, res, next) {
				  Promise.resolve()
				  .then(function(rel){
				      // afaga
				      console.log("some code")
				      res.send("ok")
				  }).catch(next)
				},function (  err, req, res, next) {  
				  res.send("the promise caught the error")
				}); 		 				
		 			all async code must return promises if they do not convert the base object 
		 			using a helper function like Bluebird.promisifyAll().  
		 			Event emitters (like streams) can still cause uncaught exceptions. 
		 			handle properly like this 

								const wrap = fn => (...args) => fn(...args).catch(args[2])

								app.get('/', wrap(async (req, res, next) => {
								  let company = await getCompanyById(req.query.id)
								  let stream = getLogoStreamById(company.id)
								  stream.on('error', next).pipe(res)
								}))		 			

	 			
		file: performance_practices/promise_error_handler.js
E-> be careful for promise catching software it can listen for routes its not supposed to try not to use this 		






														E -> X -> P -> R -> E -> S -> S ->

Set NODE ENV to production   


																					E -> X -> P -> R -> E -> S -> S ->	

Express Objects
express.urlencoded([options])

for  urlencoded http requests 


E -> X -> P -> R -> E -> S -> S ->	
Application Object 

you can get the express app like this
res.app || req.app 


app.locals
	local impt var for the app 
		if you remove a custom setting in your app, app.locals does not save it 
FILE:App_object/app_object.js

app.mountpath
	tells you where your sub path was mounted
		express.Router() doesnt have thiss
			if there is more than one mounthpath  an array 
FILE:App_object/app_mountpath.js		




app.on('mount', callback(parent))
	.emit() sub-app mount on parent app
		parent only arg
			cannot see full parent object in v8 debugger 
FILE:App_object/app_mountpath.js				

app.all(path, callback [, callback ...])
		This method is like the standard app.METHOD() methods it matches all HTTP verbs.
			app.all('*', requireAuthentication, loadUser);
				means everything that has to go through that middleware before it can continue 
			app.all('/api/*', requireAuthentication);
				whitelist functionality

app.delete(path, callback [, callback ...])
		routes HTTP delete req 
				app.delete('/', function (req, res) {
				  res.send('DELETE request to homepage');
				});						

app.disable(name)
	same as app.set(name,false)				


app.disabled(name)
	checks if name == false 


app.enable(name)
	same as app.set(name,true)

app.enabled(name)
	if name == true return true 

app.engine(ext, callback)
	were not looking at this 

app.get(name)
	returns appt setting value 		
FILE:App_object/app_mountpath.js						

app.listen(path, [callback])
	sets up a UNIX socket and listens for requests there 	
		same as http.Server.listen().

	app.listen([port[, host[, backlog]]][, callback])
		no port or omitted the OS will give it an unused port 

	the express() is actually a function passed to node http server 
	to help it handle requests 


app.METHOD(path, callback [, callback ...])

all http methods express supports
checkout
copy
delete
get
head
lock
merge
mkactivity
mkcol
move
m-search
notify
options
patch
post
purge
put
report
search
subscribe
trace
unlock
unsubscribe

to use a non http method 
app['m-search']('/', ()=>{})
app.all loads even for non http methods 




app.param([name], callback)
where name is a :param in a app http method path  
callaback == function(req, res, next, id)
	if name == string ,param == id 
		if name == array write like this  
		name = ['param1','param2']
			and the callaback is registered for each param in order 
				app.params is only local to its parent app or router and they are not inherited
				by children

				app.params only trigger once even if multiple paths match it 
file : App_object/app_param.js
	you can also rewrite app.param behavior however this is deprecated 
